diff --git a/server/services/payment/controllers/payment.controller.js b/server/services/payment/controllers/payment.controller.js
index 3ff1f9f..1133624 100644
--- a/server/services/payment/controllers/payment.controller.js
+++ b/server/services/payment/controllers/payment.controller.js
@@ -2,7 +2,7 @@ import CreateError from "http-errors";
 import PaymentModel from "../models/PaymentModel.js";
 import { sendOtpCode } from "../helpers/email.helper.js";
 import { generatePaymentId } from "../helpers/payment.helper.js";
-import { sendQueue } from "../../../shared/messages/rabbitMQ.js";
+import { publishMessage } from "../../../shared/messages/rabbitMQ.js";
 const createPayment = async (req, res, next) => {
   try {
     const { tuition, payer } = req.body;
@@ -10,6 +10,9 @@ const createPayment = async (req, res, next) => {
     if (!tuition || !payer)
       throw CreateError.BadRequest("Tuition or payer is missing");
 
+    if (payer.balance < tuition.amount)
+        throw CreateError.BadRequest("Payer balance is not enough to pay")
+
     const paymentId = generatePaymentId(tuition);
 
     const paidPayment = await PaymentModel.findOne({paymentId, status: "SUCCESS"})
@@ -19,17 +22,17 @@ const createPayment = async (req, res, next) => {
 
     const otpCode = Math.floor(Math.random() * 900000 + 100000);
 
-    await sendOtpCode(payer.email, payer.fullname, otpCode);
+    // await sendOtpCode(payer.email, payer.fullname, otpCode);
 
     const otpExpireAt = new Date(Date.now() + 1000 * 60 * 5);
 
-
     const payment = await PaymentModel.create({
       paymentId,
       tuitionId: tuition._id,
       payerId: payer.username,
       otpCode,
       otpExpireAt,
+      amount: tuition.amount
     });
 
     return res.status(201).json({
@@ -73,10 +76,9 @@ const processPayment = async (req, res, next) => {
     foundPayment.otpCode = undefined;
     foundPayment.otpExpireAt = undefined;
     await foundPayment.save();
-    
-    await sendQueue("payment_success", JSON.stringify(payment));
-    console.log("Sent queue payment_success")
 
+    await publishMessage("payment_success", JSON.stringify(foundPayment))
+    
     return res.status(200).json({
       message: "Payment is successfully!",
       payment: foundPayment,
@@ -97,7 +99,7 @@ const sendOtp = async (req, res, next) => {
       throw CreateError.BadRequest("Payment object ID is required");
 
     const otpCode = Math.floor(Math.random() * 900000 + 100000);
-    await sendOtpCode(payer.email, payer.fullname, otpCode);
+    // await sendOtpCode(payer.email, payer.fullname, otpCode);
     const otpExpireAt = new Date(Date.now() + 1000 * 60 * 5);
 
     await PaymentModel.updateOne(
diff --git a/server/services/payment/models/PaymentModel.js b/server/services/payment/models/PaymentModel.js
index 1422ddd..d0d9b43 100644
--- a/server/services/payment/models/PaymentModel.js
+++ b/server/services/payment/models/PaymentModel.js
@@ -12,6 +12,7 @@ const paymentSchema = new mongoose.Schema(
       enum: ["PENDING", "SUCCESS", "FAILED"],
       default: "PENDING",
     },
+    amount: { type: Number, required: true, min: 0 },
   },
   { timestamps: true, collection: "payments" }
 );
diff --git a/server/services/tuition/messages/tutitionConsumer.js b/server/services/tuition/messages/tutitionConsumer.js
index f51bcb2..e46f5ab 100644
--- a/server/services/tuition/messages/tutitionConsumer.js
+++ b/server/services/tuition/messages/tutitionConsumer.js
@@ -1,5 +1,7 @@
-// tuitionConsumer.js
-import { consumeQueue } from "../../../shared/messages/rabbitMQ.js";
+import {
+  consumeQueue,
+  subscribeMessage,
+} from "../../../shared/messages/rabbitMQ.js";
 import ReplicaUserModel from "../models/ReplicaUserModel.js";
 import TuitionModel from "../models/TuitionModel.js";
 
@@ -7,20 +9,22 @@ const startConsumer = async () => {
   try {
     await consumeQueue("user_created", async (msg) => {
       const user = JSON.parse(msg);
-      console.log("Consume user:", user);
-
       await ReplicaUserModel.create(user);
     });
 
-    await consumeQueue("payment_success", async (msg) => {
-      const payment = JSON.parse(msg);
-      console.log("Consume payment:", payment);
-
-      await TuitionModel.updateOne(
-        { _id: payment.tuitionId },
-        { status: "PAID" }
-      );
-    });
+    await subscribeMessage(
+      "payment_success",
+      "queue_deduct_tuition",
+      async (msg) => {
+        const payment = JSON.parse(msg);
+        const updated = await TuitionModel.findByIdAndUpdate(
+          payment.tuitionId,
+          { status: "PAID" }
+        );
+        if (updated) console.log("Deducted tutition");
+        else throw new Error("Failed to deducted tutition");
+      }
+    );
   } catch (error) {
     console.log(error);
   }
diff --git a/server/services/user/server.js b/server/services/user/server.js
index e3966d4..4e49a7b 100644
--- a/server/services/user/server.js
+++ b/server/services/user/server.js
@@ -5,6 +5,7 @@ import dotenv from "dotenv";
 import connectDB from "./database/connectDB.js";
 import router from "./routes/user.route.js";
 import errorHandler from "../../shared/middlewares/errorHandler.js"
+import { startConsumer } from "./messages/userConsumer.js";
 dotenv.config({ quite: true });
 
 const app = express();
@@ -23,4 +24,5 @@ app.use(errorHandler);
 app.listen(PORT, async () => {
   console.log(`Users service on ${PORT}`);
   await connectDB();
+  await startConsumer();
 });
diff --git a/server/shared/messages/rabbitMQ.js b/server/shared/messages/rabbitMQ.js
index 93f54b3..de54d91 100644
--- a/server/shared/messages/rabbitMQ.js
+++ b/server/shared/messages/rabbitMQ.js
@@ -19,6 +19,7 @@ const sendQueue = async (queueName, message) => {
     await channel.assertQueue(queueName, { durable: true });
 
     channel.sendToQueue(queueName, Buffer.from(message), { persistent: true });
+    console.log(`Sent to queue "${queueName}":`, message);
   } catch (error) {
     console.error(error);
   } finally {
@@ -41,9 +42,82 @@ const consumeQueue = async (queueName, callback) => {
         channel.ack(msg);
       }
     });
+    console.log(`Consume on queue "${queueName}"`);
   } catch (error) {
-    console.log(error);
+    console.error(error);
   }
 };
 
-export { sendQueue, consumeQueue };
+const publishMessage = async (exchangeName, message) => {
+  let conn, channel;
+  try {
+    conn = await connectMQ();
+    channel = await conn.createChannel();
+
+    await channel.assertExchange(exchangeName, "fanout", { durable: true });
+
+    channel.publish(exchangeName, "", Buffer.from(message), { persistent: true });
+    console.log(`Published to exchange "${exchangeName}":`, message);
+  } catch (error) {
+    console.error(error);
+  } finally {
+    if (channel) await channel.close();
+    if (conn) await conn.close();
+  }
+};
+
+const subscribeMessage = async (exchangeName, queueName, callback) => {
+  try {
+    const conn = await connectMQ();
+    const channel = await conn.createChannel();
+
+    await channel.assertExchange(exchangeName, "fanout", { durable: true });
+    await channel.assertQueue(queueName, { durable: true });
+    await channel.bindQueue(queueName, exchangeName, "");
+
+    await channel.consume(queueName, async (msg) => {
+      if (msg) {
+        const content = msg.content.toString();
+        await callback(content);
+        channel.ack(msg);
+      }
+    });
+
+    console.log(`Subscribed to exchange "${exchangeName}" on queue "${queueName}"`);
+  } catch (error) {
+    console.error(error);
+  }
+};
+
+const resetMQ = async (exchangeName, queues = []) => {
+  let conn, channel;
+  try {
+    conn = await connectMQ();
+    channel = await conn.createChannel();
+
+    // Xóa exchange cũ (nếu có)
+    await channel.deleteExchange(exchangeName).catch(() => {});
+    // Tạo exchange mới (fanout)
+    await channel.assertExchange(exchangeName, "fanout", { durable: true });
+
+    for (const queueName of queues) {
+      // Xóa queue cũ (nếu có)
+      await channel.deleteQueue(queueName).catch(() => {});
+      // Tạo queue mới
+      await channel.assertQueue(queueName, { durable: true });
+      // Bind queue với exchange
+      await channel.bindQueue(queueName, exchangeName, "");
+      console.log(`[✔] Queue "${queueName}" bound to exchange "${exchangeName}"`);
+    }
+
+    console.log(`[✔] Reset exchange "${exchangeName}" thành công`);
+  } catch (err) {
+    console.error("Reset MQ error:", err);
+  } finally {
+    if (channel) await channel.close();
+    if (conn) await conn.close();
+  }
+};
+
+
+export { sendQueue, consumeQueue, publishMessage, subscribeMessage, resetMQ };
